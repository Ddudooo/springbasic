# [스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)

스프링은 객체 지향 프로그래밍의 장점을 최대한 살리려고 노력한 결과로 나온 프레임워크

아래와 같은 개념을 추구한다

- 단순함
    - 객체 지향적으로 작성하며, 언어의 장점을 살릴 수 있게
    - POJO 를 통한 단순화한 객체의 표현
- 유연성
    - 뛰어난 확장성으로 다른 프레임워크와 쉽게 결합하여 사용할 수 있게

객체 지향 프로그래밍 5원칙으로 불리는 __SOLID__ 라고 있는데

내용은 다음과 같다

* 단일 책임 원칙  
  `SRP` Single Responsibility Principle
    * 한 클래스는 하나의 책임만 가져야 한다.
* 개방-폐쇄 원칙  
  `OCP` Open/Closed Principle
    * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
* 리스코프 치환 원칙  
  `LSP` Liskov Substitution Principle
    * 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서  
      하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* 인터페이스 분리의 원칙  
  `ISP` Interface Segregation Principle
    * 클라이언트가 자신과 관련이 없는 인터페이스는 구현하지 않아야 한다.
* 의존 관계 역전 원칙  
  `DIP` Dependecy Inversion Principle
    * 고차원 모듈 및 객체는 저차원 모듈 및 객체에 의존하면 안된다.
    * 추상화는 세부사항에 의존해서는 안되고, 세부사항은 추상화에 의존해야 한다.

---

SOLID 원칙을 지키다 보면, `OCP`, `DIP` 원칙을 준수하기 위해

객체간의 의존관계를 생성 및 조합해주는 역할을 해주어야 한다.

여기서 `관심사의 분리` 를 통해

> 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정용 객체

실제 애플리케이션이 사용되는 영역, 사용 영역과

애플리케이션 객체의 생성 및 구성을 담당하는, 구성 영역으로 분리하여

SOLID 원칙을 준수하는 코드를 생성하자

원칙을 준수하다보면 자연스럽게 IoC, DI를 구현하게 된다.

## `IoC` Inversion of Control 제어의 역전이란?

> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라  
> 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

## `DI` Dependency Injection 의존관계 주입이란?

> 외부로부터 메모리에 올라간 인스턴스의 레퍼런스를  
> 인터페이스 타입의 파라미터로 의존관계를 설정하는 것이다.

## IoC 컨테이너, DI 컨테이너

* AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
* IoC 컨테이너 또는 DI 컨테이너라 한다.
* 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
* 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

---

스프링을 적용하면 위에서 다룬 내용을 손쉽게 사용할 수 있게 해준다.

## 스프링 컨테이너

* `ApplicationContext` 를 스프링 컨테이너라 한다.
* 기존에는 개발자가 `AppConfig` 를 사용해서 직접 객체를 생성하고 DI를 했지만,  
  이제부터는 스프링 컨테이너를 통해서 사용한다.
* 스프링 컨테이너는 `@Configuration` 이 붙은 AppConfig 를 설정(구성) 정보로 사용한다.  
  여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.  
  이렇게 스프링 컨테이너에 등록된 객체를 __스프링 빈__ 이라 한다.
* 스프링 빈은 `@Bean` 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.
* 스프링 빈은 `applicationContext.getBean()` 메서드를 사용해서 찾을 수 있다.
* 기존에는 개발자가 직접 자바코드로 모든 것을 했다면  
  이제부터는 __스프링 컨테이너에 객체를 스프링 빈으로 등록__ 하고,  
  __스프링 컨테이너에서 스프링 빈을 찾아서 사용__ 하도록 변경되었다

## 스프링 빈 조회 - 기본

스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법

* `ac.getBean(빈이름, 타입)`
* `ac.getBean(타입)`
* 조회 대상 스프링 빈이 없으면 예외 발생
    * `NoSuchBeanDefinitionException: No bean named 'xxxxx' available`

## 스프링 빈 조회 - 동일한 타입이 둘 이상

* 타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다.  
  이때는 빈 이름을 지정하자.
* `ac.getBeansOfType()` 을 사용하면 해당 타입의 모든 빈을 조회할 수 있다.

## 스프링 빈 조회 - 상속 관계

부모 타입으로 조회하면, 자식 타입도 함께 조회한다.  
그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면,  
모든 스프링 빈을 조회한다.

---

# BeanFactory와 ApplicationContext

## BeanFactory

* 스프링 컨테이너의 최상위 인터페이스다.
* 스프링 빈을 관리하고 조회하는 역할을 담당한다.
* `getBean()` 을 제공한다.
* 지금까지 우리가 사용했던 대부분의 기능은 `BeanFactory`가 제공하는 기능이다.

## ApplicationContext

* `BeanFactory` 기능을 모두 상속받아서 제공한다.
* 빈을 관리하고 검색하는 기능을 `BeanFactory`가 제공해주는데,  
  그러면 둘의 차이가 뭘까?
* 애플리케이션을 개발할 때는 빈은 관리하고 조회하는 기능은 물론이고,  
  수 많은 부가기능이 필요하다.

### 정리

* `ApplicationContext`는 `BeanFactory`의 기능을 상속받는다.
* `ApplicationContext`는 빈 관리기능 + 편리한 부가 기능을 제공한다.
* `BeanFactory`를 직접 사용할 일은 거의 없다.  
  부가기능이 포함된 `ApplicationContext`를 사용한다.
* `BeanFactory`나 `ApplicationContext`를 스프링 컨테이너라 한다.

---

# 스프링 빈 설정 메타 정보 - BeanDefinition

* 스프링에서 다양한 설정 형식 지원을 위해 제공한 추상화
* 빈 설정 메타 정보
* 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다

## BeanDefinition

* `BeanClassName`
    * 생성할 빈의 클래스 명  
      (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
* `factoryBeanName`
    * 팩토리 역할의 빈을 사용할 경우 이름  
      예) appConfig
* `factoryMethodName`
    * 빈을 생성할 팩토리 메서드 지정  
      예) memberService
* `Scope`
    * 싱글톤(기본값)
* `lazyInit`
    * 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라,  
      실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부
* `InitMethodName`
    * 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
* `DestroyMethodName`
    * 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
* `Constructor`
    * arguments, Properties: 의존관계 주입에서 사용한다.  
      (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

---

# 웹 애플리케이션과 싱글톤

서버사이드에서 요청당 새로운 인스턴스를 생성하면

메모리 낭비가 심하기에 싱글턴 패턴과 같이 객체를 공유하는 설계방식을 사용한다.

## 싱글톤 패턴

싱글톤 패턴을 구현하는 방식은 여러가지가 있으나

보편적으로 사용되는 객체를 미리 생성해두는 단순한 방식을 기반으로 설명한다

싱글톤 패턴은 객체를 전체 애플리케이션에서 단 하나의 객체를 공유하여 사용하는데

아래와 같은 문제점을 지니고 있다

* 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
* 의존관계상 클라이언트가 구체 클래스에 의존한다.  
  __DIP를 위반한다.__
* 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
* 테스트하기 어렵다.
* 내부 속성을 변경하거나 초기화 하기 어렵다.
* `private` 생성자로 자식 클래스를 만들기 어렵다.
* 결론적으로 유연성이 떨어진다.
* 안티패턴으로 불리기도 한다.

이러한 문제점을 해결하기위해 스프링에서는 스프링 빈을 통한 관리방법을 사용한다.

## 싱글톤 컨테이너

* 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도,  
  객체 인스턴스를 싱글톤으로 관리한다.
    * 컨테이너는 객체를 하나만 생성해서 관리한다.
* 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.  
  이렇게 싱글톤 객체를 생성하고 관리하는 기능을 __싱글톤 레지스트리__ 라 한다.
* 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서  
  객체를 싱글톤으로 유지할 수 있다.
* 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
* DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

## 싱글톤 방식의 주의점

싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든,  
객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은  
여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에  
싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.

* 무상태(stateless)로 설계해야 한다.
* 특정 클라이언트에 의존적인 필드가 있으면 안된다.
* 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
* 가급적 읽기만 가능해야 한다.
* 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

## @Configuration과 바이트코드 조작

스프링 설정정보를 애노테이션 `@Configuration`으로 생성할시

바이트 코드를 조작하여 의존관계가 설정한 빈에서 제대로 하나의 빈만 호출하도록 한다.

---

# 컴포넌트 스캔

스프링 빈을 컨테이너에 등록하기 위해서는

`@Bean`이나 `XML` 설정 등을 통해 설정 정보를 하나하나 나열하는 방식이 있고

스프링에서 제공하는 자동으로 빈을 찾아 등록하는 __컴포넌트 스캔__ 이라는 기능을 제공한다.

이 때 의존관계 또한 자동으로 주입해주기 위해  
`@Autowired` 라는 애노테이션과 함께 해당 기능을 제공한다.

## @ComponentScan

스프링이 제공하는 컴포넌트 스캔 방식을 이용하려면

설정 정보에 `@ComponentScan` 을 붙여주면 된다.

xml 설정의 경우 생략한다. 필요할때 공식 문서를 통해 찾자

최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데,

개인적으로는 옵션을 변경하면서 사용하기보다는  
스프링의 기본 설정에 최대한 맞추어 사용하는 것을 권장하고 선호하는 편이다.

## 중복 등록과 충돌

컴포넌트 스캔으로 자동으로 등록할 시 발생할 수 있는 문제 사항으로

1. 자동으로 빈을 등록할시 이름이 같을 경우

2. 수동으로 빈을 등록한 것과 자동으로 빈을 등록할 경우

이와 같은 경우 문제가 생길 수 있다

### 자동 빈 등록 vs 자동 빈 등록

컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.

`ConflictingBeanDefinitionException` 예외 발생

### 수동 빈 등록 vs 자동 빈 등록

이 경우 수동 빈 등록이 우선권을 가진다.  
수동 빈이 자동 빈을 오버라이딩 해버린다.

개발자가 의도적으로 이런 결과를 기대했다면, 자동 보다는 수동이 우선권을 가지는 것이 좋다

의도적으로 설정해서 이런 결과가 만들어지기보다는  
여러 설정들이 꼬여서 이런 결과가 만들어지는 경우가 대부분

최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면  
오류가 발생하도록 기본 값을 바꾸었다.

---

# 의존관계 자동 주입

의존관계 주입은 크게 4가지 방법이 있다.

1. 생성자 주입
2. 수정자 주입  
   (setter 주입)
3. 필드 주입
4. 일반 메서드 주입

## 생성자 주입

생성자를 통해서 의존 관계를 주입 받는 방법

생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.

불변, 필수 의존관계에 사용

스프링 빈의 경우 생성자가 딱 1개만 있으면 `@Autowired`를 생략해도 자동 주입 된다.

## 수정자 주입

`setter`라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법

선택, 변경 가능성이 있는 의존관계에 사용  
자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법

`@Autowired` 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다.

주입할 대상이 없어도 동작하게하려면 `@Autowired(required = false)` 로 지정하면 된다.

## 필드 주입

되도록 사용하지 말것.

필드에 바로 주입하는 방법

코드가 간결해서 많은 개발자들을 유혹하지만  
외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.

DI 프레임워크가 없으면 아무것도 할 수 없다

## 일반 메서드 주입

일반 메서드를 통해서 주입

한번에 여러 필드를 주입 받을 수 있다.

일반적으로 잘 사용하지 않는다.

## 옵션 처리

주입할 스프링 빈이 없어도 동작해야 할 때가 있다.

그런데 `@Autowired` 만 사용하면 `required` 옵션의 기본값이 `true` 로 되어 있어서  
자동 주입 대상이 없으면 오류가 발생한다.

자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.

* `@Autowired(required=false)`  
  자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨

* `org.springframework.lang.@Nullable`  
  자동 주입할 대상이 없으면 `null`이 입력된다.

* `Optional<>`  
  자동 주입할 대상이 없으면 `Optional.empty` 가 입력된다.

## 생성자 주입 방법 권장

스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장한다.

일반적으로 얻을 수 있는 장점은 아래와 같으며

이 외에도 다른 장점이 존재할 수 있다.

1. 불변성을 보장할 수 있다.
2. 테스트 코드 작성이 편리하다.
3. 애플리케이션 구동시 순환 참조 문제 파악할 수 있다.

## 조회 빈이 2개 이상

자동 주입`@Autowired`을 통해 주입할 대상을 조회할때

타입을 통해 조회하기에 조회되는 빈이 2개 이상일 때가 있다.

이때 주입 받는 대상에서 하나의 빈만 주입받을 때 `NoUniqueBeanDefinitionException` 오류가 발생한다.

이때 하위 타입으로 지정할 수 도 있지만,  
하위 타입으로 지정하는 것은 `DIP`를 위배하고 유연성이 떨어진다.

그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안된다.

스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있다.

### Autowired 필드명 매칭

필드명에 따라 추가적으로 동작하는 기능을 이용해 주입받을 대상을 지정할 수 있다.

1. 타입 매칭
2. 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭

### @Qualifier 사용

`@Qualifier` 는 추가 구분자를 붙여주는 방법이다.

주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아니다.

사용법은 다음과 같다

1. 빈 등록시 `@Qualifier`를 붙여 준다.
2. 주입시에 `@Qualifier`를 붙여주고 등록한 이름을 적어준다.

`@Qualifier` 로 주입할 때 등록한 이름을 못찾으면  
해당 이름으로 스프링 빈을 추가로 찾는다

하지만 `@Qualifier` 는 `@Qualifier` 를 찾는 용도로만 사용하는게 명확하고 좋다.

### @Primary 사용

`@Primary` 는 우선순위를 정하는 방법이다.

`@Autowired` 시에 여러 빈이 매칭되면 `@Primary` 가 우선권을 가진다.

### @Primary, @Qualifier 활용

메인 빈은 `@Primary` 를 적용해서 조회하는 곳에서 `@Qualifier` 지정 없이 편리하게 조회하고,  
서브 빈을 획득할 때는 `@Qualifier` 를 지정해서  
명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다.

물론 이때 메인 데이터베이스의 스프링 빈을 등록할 때  
`@Qualifier` 를 지정해주는 것은 상관없다.

#### 애노테이션 활용

`@Qualifier("subBean")` 이렇게 문자를 적으면 컴파일시 타입 체크가 안된다.

애노테이션을 활용해서 컴파일시에 오류를 확인하자

```java

@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER,
	ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier("subBean")
public @interface SubBean {

}
```

```java

@Component
@SubBean
public class SubBean implements SomeInterface {

}
```

```java
    public Client(@SubBean SomeInterface bean){
	this.bean=bean;
	}
```

### 조회한 빈이 모두 필요할 때

테스트 코드를 통해 구현한 예시를 통해 알아보자

[소스](chapter02/src/test/java/study/springbasic/core/autowired/AllBeanTest.java)

## 자동, 수동의 올바른 실무 운영 기준

편리한 자동 기능을 기본으로 사용하자

수동 빈 등록은

* 기술 지원 빈
    * 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다.
    * 데이터베이스 연결이나, 공통 로그 처리처럼 업무 로직을 지원하기위한 하부 기술이나 공통 기술들이다.

애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는

수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.

이 외에 비즈니스 로직 중에서 다형성을 적극 활용할 때

특정 패키지에 같이 묶어 두는 것이 코드를 보고 이해하기 편해진다.

---

# 빈 생명주기 콜백

스프링 빈의 이벤트 라이프사이클
`스프링 컨테이너 생성` -> `스프링 빈 생성` ->
`의존관계 주입` -> `초기화 콜백` -> `사용` -> `소멸전 콜백` -> `스프링 종료`

* 초기화 콜백  
  빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
* 소멸전 콜백  
  빈이 소멸되기 직전에 호출

스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.

* 인터페이스(`InitializingBean`, `DisposableBean`)
* 설정 정보에 초기화 메서드, 종료 메서드 지정
* `@PostConstruct`, `@PreDestory` 애노테이션 지원

각 사용방법은 생략.

---

# 빈 스코프

스프링은 다음과 같은 다양한 스코프를 지원한다.

* 싱글톤
    * 기본 스코프
    * 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
* 프로토타입
    * 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고  
      더는 관리하지 않는 매우 짧은 범위의 스코프이다.

웹 관련 스코프

* request
    * 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.
* session
    * 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
* application
    * 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프이다.

## 프로토타입 빈

스프링 컨테이너에 요청할 때 마다 새로 생성된다.  
스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.  
종료 메서드가 호출되지 않는다.

__그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다.__

__종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.__

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

프로토타입 빈을 요청시마다 새로 생성하려고 할때

프로토타입 빈을 싱글톤빈에 주입해서 사용할시에 문제가 생긴다

싱글톤 빈 주입시에 프로토타입 빈이 주입되어

싱글톤 빈에서 프로토타입 빈의 메소드 호출시 동일한 빈으로 호출이 된다.

요청시마다 새로 생성하려는 의도와 달라진다는 말

#### Provider로 문제 해결

의존관계 주입에서 의존관계 탐색으로 변경하여

사용하는 객체에서 직접 의존관계에 놓여진 객체를 찾아 사용하는 방식으로 변경하여 해결한다.

의존관계를 찾는 것을 `Dependency Lookup (DL)` 의존관계 조회(탐색)이라 한다.

##### ObjectFactory, ObjectProvider

지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 `ObjectProvider` 이다.

* ObjectFactory
    * 기능이 단순
    * 별도의 라이브러리 필요 없음
    * 스프링에 의존
* ObjectProvider
    * ObjectFactory 상속, 옵션, 스트림 처리등 편의 기능이 많음
    * 별도의 라이브러리 필요없음
    * 스프링에 의존

##### JSR-330 Provider

javax.inject.Provider 라는 JSR-330 자바 표준을 사용하는 방법이다.

이 방법을 사용하려면 `javax.inject:javax.inject:1` 라이브러리를 `gradle`에 추가해야 한다.

```groovy
dependency {
    implementation 'javax.inject:javax.inject:1'
}
```

`provider` 의 `get()` 을 호출하면  
내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)

자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.

Provider 는 지금 딱 필요한 DL 정도의 기능만 제공한다.

`get()` 메서드 하나로 기능이 매우 단순하다.

별도의 라이브러리가 필요하다.

자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.

## 웹 스코프

* 웹 스코프는 웹 환경에서만 동작한다.
* 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다.  
  따라서 종료 메서드가 호출된다.

웹 스코프 종류

* request
    * HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프
    * 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
* session
    * `HTTP Session`과 동일한 생명주기를 가지는 스코프
* application
    * 서블릿 컨텍스트(`ServletContext`)와 동일한 생명주기를 가지는 스코프
* websocket
    * 웹 소켓과 동일한 생명주기를 가지는 스코프

request 스코프를 사용한 예시 코드를 통해 알아보자

[예시](chapter02/src/main/java/study/springbasic/core/common/MyLogger.java)

## 스코프와 프록시

* `CGLIB`라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.
* 이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.
* 가짜 프록시 객체는 실제 `request scope`와는 관계가 없다.  
  그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다.

### 특징

* 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 사용할 수 있다.
* 사실 `Provider`를 사용하든, 프록시를 사용하든  
  핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 __지연처리__ 한다는 점이다.
* 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다.  
  이것이 바로 __다형성__ 과 __DI 컨테이너__ 가 가진 큰 강점이다.
