# [스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)

스프링은 객체 지향 프로그래밍의 장점을 최대한 살리려고 노력한 결과로 나온 프레임워크

아래와 같은 개념을 추구한다

- 단순함
    - 객체 지향적으로 작성하며, 언어의 장점을 살릴 수 있게
    - POJO 를 통한 단순화한 객체의 표현
- 유연성
    - 뛰어난 확장성으로 다른 프레임워크와 쉽게 결합하여 사용할 수 있게

객체 지향 프로그래밍 5원칙으로 불리는 __SOLID__ 라고 있는데

내용은 다음과 같다

* 단일 책임 원칙  
  `SRP` Single Responsibility Principle
    * 한 클래스는 하나의 책임만 가져야 한다.
* 개방-폐쇄 원칙  
  `OCP` Open/Closed Principle
    * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
* 리스코프 치환 원칙  
  `LSP` Liskov Substitution Principle
    * 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서  
      하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* 인터페이스 분리의 원칙  
  `ISP` Interface Segregation Principle
    * 클라이언트가 자신과 관련이 없는 인터페이스는 구현하지 않아야 한다.
* 의존 관계 역전 원칙  
  `DIP` Dependecy Inversion Principle
    * 고차원 모듈 및 객체는 저차원 모듈 및 객체에 의존하면 안된다.
    * 추상화는 세부사항에 의존해서는 안되고, 세부사항은 추상화에 의존해야 한다.

---

SOLID 원칙을 지키다 보면, `OCP`, `DIP` 원칙을 준수하기 위해

객체간의 의존관계를 생성 및 조합해주는 역할을 해주어야 한다.

여기서 `관심사의 분리` 를 통해

> 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정용 객체

실제 애플리케이션이 사용되는 영역, 사용 영역과

애플리케이션 객체의 생성 및 구성을 담당하는, 구성 영역으로 분리하여

SOLID 원칙을 준수하는 코드를 생성하자

원칙을 준수하다보면 자연스럽게 IoC, DI를 구현하게 된다.

## `IoC` Inversion of Control 제어의 역전이란?

> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라  
> 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

## `DI` Dependency Injection 의존관계 주입이란?

> 외부로부터 메모리에 올라간 인스턴스의 레퍼런스를  
> 인터페이스 타입의 파라미터로 의존관계를 설정하는 것이다.

## IoC 컨테이너, DI 컨테이너

* AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
* IoC 컨테이너 또는 DI 컨테이너라 한다.
* 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
* 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

---

스프링을 적용하면 위에서 다룬 내용을 손쉽게 사용할 수 있게 해준다.

## 스프링 컨테이너

* `ApplicationContext` 를 스프링 컨테이너라 한다.
* 기존에는 개발자가 `AppConfig` 를 사용해서 직접 객체를 생성하고 DI를 했지만,  
  이제부터는 스프링 컨테이너를 통해서 사용한다.
* 스프링 컨테이너는 `@Configuration` 이 붙은 AppConfig 를 설정(구성) 정보로 사용한다.  
  여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.  
  이렇게 스프링 컨테이너에 등록된 객체를 __스프링 빈__ 이라 한다.
* 스프링 빈은 `@Bean` 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.
* 스프링 빈은 `applicationContext.getBean()` 메서드를 사용해서 찾을 수 있다.
* 기존에는 개발자가 직접 자바코드로 모든 것을 했다면  
  이제부터는 __스프링 컨테이너에 객체를 스프링 빈으로 등록__ 하고,  
  __스프링 컨테이너에서 스프링 빈을 찾아서 사용__ 하도록 변경되었다

## 스프링 빈 조회 - 기본

스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법

* `ac.getBean(빈이름, 타입)`
* `ac.getBean(타입)`
* 조회 대상 스프링 빈이 없으면 예외 발생
    * `NoSuchBeanDefinitionException: No bean named 'xxxxx' available`

## 스프링 빈 조회 - 동일한 타입이 둘 이상

* 타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다.  
  이때는 빈 이름을 지정하자.
* `ac.getBeansOfType()` 을 사용하면 해당 타입의 모든 빈을 조회할 수 있다.

## 스프링 빈 조회 - 상속 관계

부모 타입으로 조회하면, 자식 타입도 함께 조회한다.  
그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면,  
모든 스프링 빈을 조회한다.

---

# BeanFactory와 ApplicationContext

## BeanFactory

* 스프링 컨테이너의 최상위 인터페이스다.
* 스프링 빈을 관리하고 조회하는 역할을 담당한다.
* `getBean()` 을 제공한다.
* 지금까지 우리가 사용했던 대부분의 기능은 `BeanFactory`가 제공하는 기능이다.

## ApplicationContext

* `BeanFactory` 기능을 모두 상속받아서 제공한다.
* 빈을 관리하고 검색하는 기능을 `BeanFactory`가 제공해주는데,  
  그러면 둘의 차이가 뭘까?
* 애플리케이션을 개발할 때는 빈은 관리하고 조회하는 기능은 물론이고,  
  수 많은 부가기능이 필요하다.

### 정리

* `ApplicationContext`는 `BeanFactory`의 기능을 상속받는다.
* `ApplicationContext`는 빈 관리기능 + 편리한 부가 기능을 제공한다.
* `BeanFactory`를 직접 사용할 일은 거의 없다.  
  부가기능이 포함된 `ApplicationContext`를 사용한다.
* `BeanFactory`나 `ApplicationContext`를 스프링 컨테이너라 한다.

---

# 스프링 빈 설정 메타 정보 - BeanDefinition

* 스프링에서 다양한 설정 형식 지원을 위해 제공한 추상화
* 빈 설정 메타 정보
* 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다

## BeanDefinition

* `BeanClassName`
    * 생성할 빈의 클래스 명  
      (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
* `factoryBeanName`
    * 팩토리 역할의 빈을 사용할 경우 이름  
      예) appConfig
* `factoryMethodName`
    * 빈을 생성할 팩토리 메서드 지정  
      예) memberService
* `Scope`
    * 싱글톤(기본값)
* `lazyInit`
    * 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라,  
      실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부
* `InitMethodName`
    * 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
* `DestroyMethodName`
    * 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
* `Constructor`
    * arguments, Properties: 의존관계 주입에서 사용한다.  
      (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

---

# 웹 애플리케이션과 싱글톤

서버사이드에서 요청당 새로운 인스턴스를 생성하면

메모리 낭비가 심하기에 싱글턴 패턴과 같이 객체를 공유하는 설계방식을 사용한다.

## 싱글톤 패턴

싱글톤 패턴을 구현하는 방식은 여러가지가 있으나

보편적으로 사용되는 객체를 미리 생성해두는 단순한 방식을 기반으로 설명한다

싱글톤 패턴은 객체를 전체 애플리케이션에서 단 하나의 객체를 공유하여 사용하는데

아래와 같은 문제점을 지니고 있다

* 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
* 의존관계상 클라이언트가 구체 클래스에 의존한다.  
  __DIP를 위반한다.__
* 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
* 테스트하기 어렵다.
* 내부 속성을 변경하거나 초기화 하기 어렵다.
* `private` 생성자로 자식 클래스를 만들기 어렵다.
* 결론적으로 유연성이 떨어진다.
* 안티패턴으로 불리기도 한다.

이러한 문제점을 해결하기위해 스프링에서는 스프링 빈을 통한 관리방법을 사용한다.

## 싱글톤 컨테이너

* 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도,  
  객체 인스턴스를 싱글톤으로 관리한다.
    * 컨테이너는 객체를 하나만 생성해서 관리한다.
* 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.  
  이렇게 싱글톤 객체를 생성하고 관리하는 기능을 __싱글톤 레지스트리__ 라 한다.
* 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서  
  객체를 싱글톤으로 유지할 수 있다.
* 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
* DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

## 싱글톤 방식의 주의점

싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든,  
객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은  
여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에  
싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.

* 무상태(stateless)로 설계해야 한다.
* 특정 클라이언트에 의존적인 필드가 있으면 안된다.
* 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
* 가급적 읽기만 가능해야 한다.
* 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.